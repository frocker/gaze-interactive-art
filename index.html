<!DOCTYPE html>
<html>
<head>
  <style>
  body{
    font-family:Helvetica;
    margin:0;
    background:black;
  }
    #infoText{
      width:100%;
      box-sizing: border-box;
      padding:20px;
      position:absolute;
      font-size:16pt;
      color:white;
      background-color:rgba(0, 0, 0, 0.5);
      text-align:center;
      visibility:hidden;
    }
  </style>

</head>

<body>
<div id="infoText"></div>
<canvas id="canvas" style="background-size:contain;margin-left:auto;margin-right:auto;display:block;">
</canvas>



<script>
//Get Gaze coordinates
var ipc = require('electron').ipcRenderer;
ipc.on('gaze-pos', (event, arg) => {
  if(arg.timestamp )
  gazePosition.x = arg.x;
  gazePosition.y = arg.y;
});
var gazePosition = {x : 0, y: 0};

/*Load Image here*/
let params = (new URL(location)).searchParams;
var paintingId = params.get("painting");
console.log(paintingId);

var paintingInfo = require('./paintings/'+paintingId+'.json');

var canvas = document.getElementById("canvas"),
    ctx = canvas.getContext("2d");

canvas.style.backgroundImage = 'url('+paintingInfo.image+')';

var viewport = {width:undefined, height:undefined, aspectratio: undefined};
viewport.width = window.innerWidth;
viewport.height = window.innerHeight;
viewport.aspectratio = viewport.width/viewport.height;

paintingInfo.aspectratio = paintingInfo.width/paintingInfo.height;


var imageDefault = new Image();
imageDefault.src = paintingInfo.image;
var renderedScaleFactor;
//console.log(viewport);
//console.log(imageDimensions);
if(viewport.aspectratio<paintingInfo.aspectratio){
  //Fit width
  canvas.width = viewport.width;
  canvas.height = paintingInfo.height * (canvas.width/paintingInfo.width);
  renderedScaleFactor = canvas.width/paintingInfo.width;
} else {
  //Fit Height
  canvas.height = viewport.height;
  canvas.width = paintingInfo.width * (canvas.height/paintingInfo.height);
  renderedScaleFactor = canvas.height/paintingInfo.height;
}
var canvasMargin = canvas.getBoundingClientRect().left;
var imageDataDefault;
var pixelsDefault;
var numPixels;

var imageModulated = new Image();   
var imageDataModulated;
var pixelsModulated;

var gazePointsCanvas = new Array();


imageDefault.onload = function(){
  console.log("Loaded Default Image");

    //Create Modulated Image from original
    ctx.drawImage(imageDefault,0,0, canvas.width, canvas.height);
    imageDataDefault = ctx.getImageData(0, 0, canvas.width, canvas.height);
    imageDataModulated = ctx.getImageData(0, 0, canvas.width, canvas.height);
    pixelsDefault = imageDataDefault.data;
    numPixels = imageDataDefault.width * imageDataDefault.height;
    pixelsModulated  = imageDataModulated.data;

    for (var i = 0; i < numPixels; i++) {
      pixelsModulated[i*4] = pixelsDefault[i*4] * 1.2; // Red
      pixelsModulated[i*4+1] = pixelsDefault[i*4+1] * 1.2; // Green
      pixelsModulated[i*4+2] = pixelsDefault[i*4+2] * 1.2; // Blue
    }
    ctx.putImageData(imageDataModulated, 0, 0);
     imageModulated.src = canvas.toDataURL(); //Is this async?
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

imageModulated.onload = function(){
  console.log("img modulated loaded");
 

  setupGazepoints();

  render();
}

var renderPoints = true;
var on = true;

var fps = 5;
var now;
var then = Date.now();
var interval = 1000/fps;
var delta;

var DWELL_TIME = 2000;

function render() {
  now = Date.now();
  delta = now - then;

  if (delta > interval) {
    on = !on;
    then = now - (delta % interval);
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (renderPoints & on){
    for (var i = 0; i < paintingInfo.gazePoints.length; i++) {
      if(paintingInfo.gazePoints[i].enabled){
        if(!gazingAtPoint(paintingInfo.gazePoints[i].x*renderedScaleFactor,paintingInfo.gazePoints[i].y*renderedScaleFactor,paintingInfo.gazePoints[i].r*renderedScaleFactor)){
          paintingInfo.gazePoints[i].dwelltime = 0;
          ctx.drawImage(gazePointsCanvas[i], 0, 0);
        } else {
          paintingInfo.gazePoints[i].dwelltime += delta;
          if(paintingInfo.gazePoints[i].dwelltime>DWELL_TIME){
            paintingInfo.gazePoints[i].enabled=false;
            //set visibility to true
            document.getElementById("infoText").innerHTML=paintingInfo.gazePoints[i].text;
            document.getElementById("infoText").style.visibility="visible";
            renderPoints = false;
            setTimeout(function() { hideInfoText(); }, 8000);
          }
        }
      }
    }
  }
  requestAnimationFrame(render); 
}

function hideInfoText(){
  document.getElementById("infoText").style.visibility="hidden";
  renderPoints = true;

}

//Depro Returns true, false, for if point should be rendered.
function clipArc(context, x, y, r) {
    context.globalCompositeOperation = 'destination-in';
    context.filter = "blur(10px)";  // "feather"
    context.beginPath();

    context.arc(x, y, r, 0, 2 * Math.PI);

    /*
    //Check if mouse is in Path
    if (context.isPointInPath(gazePosition.x-canvasMargin, gazePosition.y)) {
      var renderPoint = false;
    } else {
      var renderPoint = true;
    }
    */
    context.fill();

    // reset comp. mode and filter
    context.globalCompositeOperation = 'source-over';
    context.filter = "none";
    //return renderPoint;
}

//Return true/false for if gazing at point
function gazingAtPoint(x, y, r){
  //Get x,y,r
  //Check if point in circle, use offset
  return (Math.pow((gazePosition.x - x + canvasMargin),2) + Math.pow((gazePosition.y - y),2) < Math.pow(r,2));

}

function setupGazepoints(){
  for (var i = 0; i < paintingInfo.gazePoints.length; i++) {
    paintingInfo.gazePoints[i].enabled = true;
    paintingInfo.gazePoints[i].dwelltime = 0;

    //ToDo: Create Canvases for each gp
    gazePointsCanvas.push(document.createElement('canvas'));
    var tx = gazePointsCanvas[i].getContext('2d');
    gazePointsCanvas[i].width = ctx.canvas.width;
    gazePointsCanvas[i].height = ctx.canvas.height;
    tx.drawImage(imageModulated, 0, 0);
    //tx.fillRect(0,0,1920,1080);
     clipArc(tx, paintingInfo.gazePoints[i].x*renderedScaleFactor,paintingInfo.gazePoints[i].y*renderedScaleFactor,paintingInfo.gazePoints[i].r*renderedScaleFactor);
  }
}

</script>

</body>
</html>
